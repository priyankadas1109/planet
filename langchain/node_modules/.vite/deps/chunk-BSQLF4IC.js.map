{
  "version": 3,
  "sources": ["../../@langchain/core/dist/runnables/router.js", "../../@langchain/core/dist/runnables/branch.js", "../../@langchain/core/dist/runnables/history.js"],
  "sourcesContent": ["import { Runnable } from \"./base.js\";\nimport { ensureConfig } from \"./config.js\";\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable extends Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const batchSize = maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n", "import { Runnable, _coerceToDict, _coerceToRunnable, } from \"./base.js\";\nimport { getCallbackManagerForConfig, patchConfig, } from \"./config.js\";\nimport { concat } from \"../utils/stream.js\";\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch extends Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            _coerceToRunnable(condition),\n            _coerceToRunnable(runnable),\n        ]);\n        const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, patchConfig(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = concat(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\n", "import { AIMessage, HumanMessage, isBaseMessage, } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda, } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n    constructor(fields) {\n        let historyChain = RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue) {\n        let parsedInputValue;\n        if (typeof inputValue === \"object\" &&\n            !Array.isArray(inputValue) &&\n            !isBaseMessage(inputValue)) {\n            let key;\n            if (this.inputMessagesKey) {\n                key = this.inputMessagesKey;\n            }\n            else if (Object.keys(inputValue).length === 1) {\n                key = Object.keys(inputValue)[0];\n            }\n            else {\n                key = \"input\";\n            }\n            if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                parsedInputValue = inputValue[key][0];\n            }\n            else {\n                parsedInputValue = inputValue[key];\n            }\n        }\n        else {\n            parsedInputValue = inputValue;\n        }\n        if (typeof parsedInputValue === \"string\") {\n            return [new HumanMessage(parsedInputValue)];\n        }\n        else if (Array.isArray(parsedInputValue)) {\n            return parsedInputValue;\n        }\n        else if (isBaseMessage(parsedInputValue)) {\n            return [parsedInputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let parsedOutputValue;\n        if (!Array.isArray(outputValue) &&\n            !isBaseMessage(outputValue) &&\n            typeof outputValue !== \"string\") {\n            let key;\n            if (this.outputMessagesKey !== undefined) {\n                key = this.outputMessagesKey;\n            }\n            else if (Object.keys(outputValue).length === 1) {\n                key = Object.keys(outputValue)[0];\n            }\n            else {\n                key = \"output\";\n            }\n            // If you are wrapping a chat model directly\n            // The output is actually this weird generations object\n            if (outputValue.generations !== undefined) {\n                parsedOutputValue = outputValue.generations[0][0].message;\n            }\n            else {\n                parsedOutputValue = outputValue[key];\n            }\n        }\n        else {\n            parsedOutputValue = outputValue;\n        }\n        if (typeof parsedOutputValue === \"string\") {\n            return [new AIMessage(parsedOutputValue)];\n        }\n        else if (Array.isArray(parsedOutputValue)) {\n            return parsedOutputValue;\n        }\n        else if (isBaseMessage(parsedOutputValue)) {\n            return [parsedOutputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n        }\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.configurable?.messageHistory;\n        const messages = await history.getMessages();\n        if (this.historyMessagesKey === undefined) {\n            return messages.concat(this._getInputMessages(input));\n        }\n        return messages;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        let inputs;\n        // Chat model inputs are nested arrays\n        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n            inputs = run.inputs[0];\n        }\n        else {\n            inputs = run.inputs;\n        }\n        let inputMessages = this._getInputMessages(inputs);\n        // If historic messages were prepended to the input messages, remove them to\n        // avoid adding duplicate messages to history.\n        if (this.historyMessagesKey === undefined) {\n            const existingMessages = await history.getMessages();\n            inputMessages = inputMessages.slice(existingMessages.length);\n        }\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        await history.addMessages([...inputMessages, ...outputMessages]);\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\n"],
  "mappings": "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",
  "names": ["i", "config"]
}

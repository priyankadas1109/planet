{
  "version": 3,
  "sources": ["../../@langchain/textsplitters/dist/text_splitter.js"],
  "sourcesContent": ["import { Document, BaseDocumentTransformer } from \"@langchain/core/documents\";\nimport { getEncoding } from \"@langchain/core/utils/tiktoken\";\nexport class TextSplitter extends BaseDocumentTransformer {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"document_transformers\", \"text_splitters\"]\n        });\n        Object.defineProperty(this, \"chunkSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        Object.defineProperty(this, \"chunkOverlap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 200\n        });\n        Object.defineProperty(this, \"keepSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lengthFunction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n        this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n        this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n        this.lengthFunction =\n            fields?.lengthFunction ?? ((text) => text.length);\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    async transformDocuments(documents, chunkHeaderOptions = {}) {\n        return this.splitDocuments(documents, chunkHeaderOptions);\n    }\n    splitOnSeparator(text, separator) {\n        let splits;\n        if (separator) {\n            if (this.keepSeparator) {\n                const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n            }\n            else {\n                splits = text.split(separator);\n            }\n        }\n        else {\n            splits = text.split(\"\");\n        }\n        return splits.filter((s) => s !== \"\");\n    }\n    async createDocuments(texts, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadatas = [], chunkHeaderOptions = {}) {\n        // if no metadata is provided, we create an empty one for each text\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const _metadatas = metadatas.length > 0\n            ? metadatas\n            : [...Array(texts.length)].map(() => ({}));\n        const { chunkHeader = \"\", chunkOverlapHeader = \"(cont'd) \", appendChunkOverlapHeader = false, } = chunkHeaderOptions;\n        const documents = new Array();\n        for (let i = 0; i < texts.length; i += 1) {\n            const text = texts[i];\n            let lineCounterIndex = 1;\n            let prevChunk = null;\n            let indexPrevChunk = -1;\n            for (const chunk of await this.splitText(text)) {\n                let pageContent = chunkHeader;\n                // we need to count the \\n that are in the text before getting removed by the splitting\n                const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);\n                if (prevChunk === null) {\n                    const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);\n                    lineCounterIndex += newLinesBeforeFirstChunk;\n                }\n                else {\n                    const indexEndPrevChunk = indexPrevChunk + (await this.lengthFunction(prevChunk));\n                    if (indexEndPrevChunk < indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);\n                        lineCounterIndex += numberOfIntermediateNewLines;\n                    }\n                    else if (indexEndPrevChunk > indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);\n                        lineCounterIndex -= numberOfIntermediateNewLines;\n                    }\n                    if (appendChunkOverlapHeader) {\n                        pageContent += chunkOverlapHeader;\n                    }\n                }\n                const newLinesCount = this.numberOfNewLines(chunk);\n                const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\"\n                    ? { ..._metadatas[i].loc }\n                    : {};\n                loc.lines = {\n                    from: lineCounterIndex,\n                    to: lineCounterIndex + newLinesCount,\n                };\n                const metadataWithLinesNumber = {\n                    ..._metadatas[i],\n                    loc,\n                };\n                pageContent += chunk;\n                documents.push(new Document({\n                    pageContent,\n                    metadata: metadataWithLinesNumber,\n                }));\n                lineCounterIndex += newLinesCount;\n                prevChunk = chunk;\n                indexPrevChunk = indexChunk;\n            }\n        }\n        return documents;\n    }\n    numberOfNewLines(text, start, end) {\n        const textSection = text.slice(start, end);\n        return (textSection.match(/\\n/g) || []).length;\n    }\n    async splitDocuments(documents, chunkHeaderOptions = {}) {\n        const selectedDocuments = documents.filter((doc) => doc.pageContent !== undefined);\n        const texts = selectedDocuments.map((doc) => doc.pageContent);\n        const metadatas = selectedDocuments.map((doc) => doc.metadata);\n        return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n    }\n    joinDocs(docs, separator) {\n        const text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    }\n    async mergeSplits(splits, separator) {\n        const docs = [];\n        const currentDoc = [];\n        let total = 0;\n        for (const d of splits) {\n            const _len = await this.lengthFunction(d);\n            if (total + _len + currentDoc.length * separator.length >\n                this.chunkSize) {\n                if (total > this.chunkSize) {\n                    console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n                }\n                if (currentDoc.length > 0) {\n                    const doc = this.joinDocs(currentDoc, separator);\n                    if (doc !== null) {\n                        docs.push(doc);\n                    }\n                    // Keep on popping if:\n                    // - we have a larger chunk than in the chunk overlap\n                    // - or if we still have any chunks and the length is long\n                    while (total > this.chunkOverlap ||\n                        (total + _len + currentDoc.length * separator.length >\n                            this.chunkSize &&\n                            total > 0)) {\n                        total -= await this.lengthFunction(currentDoc[0]);\n                        currentDoc.shift();\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += _len;\n        }\n        const doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"CharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        this.separator = fields?.separator ?? this.separator;\n    }\n    async splitText(text) {\n        // First we naively split the large input into a bunch of smaller ones.\n        const splits = this.splitOnSeparator(text, this.separator);\n        return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n    }\n}\nexport const SupportedTextSplitterLanguages = [\n    \"cpp\",\n    \"go\",\n    \"java\",\n    \"js\",\n    \"php\",\n    \"proto\",\n    \"python\",\n    \"rst\",\n    \"ruby\",\n    \"rust\",\n    \"scala\",\n    \"swift\",\n    \"markdown\",\n    \"latex\",\n    \"html\",\n    \"sol\",\n];\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"RecursiveCharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n        });\n        this.separators = fields?.separators ?? this.separators;\n        this.keepSeparator = fields?.keepSeparator ?? true;\n    }\n    async _splitText(text, separators) {\n        const finalChunks = [];\n        // Get appropriate separator to use\n        let separator = separators[separators.length - 1];\n        let newSeparators;\n        for (let i = 0; i < separators.length; i += 1) {\n            const s = separators[i];\n            if (s === \"\") {\n                separator = s;\n                break;\n            }\n            if (text.includes(s)) {\n                separator = s;\n                newSeparators = separators.slice(i + 1);\n                break;\n            }\n        }\n        // Now that we have the separator, split the text\n        const splits = this.splitOnSeparator(text, separator);\n        // Now go merging things, recursively splitting longer texts.\n        let goodSplits = [];\n        const _separator = this.keepSeparator ? \"\" : separator;\n        for (const s of splits) {\n            if ((await this.lengthFunction(s)) < this.chunkSize) {\n                goodSplits.push(s);\n            }\n            else {\n                if (goodSplits.length) {\n                    const mergedText = await this.mergeSplits(goodSplits, _separator);\n                    finalChunks.push(...mergedText);\n                    goodSplits = [];\n                }\n                if (!newSeparators) {\n                    finalChunks.push(s);\n                }\n                else {\n                    const otherInfo = await this._splitText(s, newSeparators);\n                    finalChunks.push(...otherInfo);\n                }\n            }\n        }\n        if (goodSplits.length) {\n            const mergedText = await this.mergeSplits(goodSplits, _separator);\n            finalChunks.push(...mergedText);\n        }\n        return finalChunks;\n    }\n    async splitText(text) {\n        return this._splitText(text, this.separators);\n    }\n    static fromLanguage(language, options) {\n        return new RecursiveCharacterTextSplitter({\n            ...options,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language),\n        });\n    }\n    static getSeparatorsForLanguage(language) {\n        if (language === \"cpp\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along function definitions\n                \"\\nvoid \",\n                \"\\nint \",\n                \"\\nfloat \",\n                \"\\ndouble \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"go\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                \"\\nvar \",\n                \"\\nconst \",\n                \"\\ntype \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"java\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along method definitions\n                \"\\npublic \",\n                \"\\nprotected \",\n                \"\\nprivate \",\n                \"\\nstatic \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"js\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                \"\\nconst \",\n                \"\\nlet \",\n                \"\\nvar \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                \"\\ndefault \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"php\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nforeach \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"proto\") {\n            return [\n                // Split along message definitions\n                \"\\nmessage \",\n                // Split along service definitions\n                \"\\nservice \",\n                // Split along enum definitions\n                \"\\nenum \",\n                // Split along option definitions\n                \"\\noption \",\n                // Split along import statements\n                \"\\nimport \",\n                // Split along syntax declarations\n                \"\\nsyntax \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"python\") {\n            return [\n                // First, try to split along class definitions\n                \"\\nclass \",\n                \"\\ndef \",\n                \"\\n\\tdef \",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rst\") {\n            return [\n                // Split along section titles\n                \"\\n===\\n\",\n                \"\\n---\\n\",\n                \"\\n***\\n\",\n                // Split along directive markers\n                \"\\n.. \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"ruby\") {\n            return [\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nunless \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\ndo \",\n                \"\\nbegin \",\n                \"\\nrescue \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rust\") {\n            return [\n                // Split along function definitions\n                \"\\nfn \",\n                \"\\nconst \",\n                \"\\nlet \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\nloop \",\n                \"\\nmatch \",\n                \"\\nconst \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"scala\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nobject \",\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nval \",\n                \"\\nvar \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nmatch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"swift\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"markdown\") {\n            return [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"latex\") {\n            return [\n                // First, try to split along Latex sections\n                \"\\n\\\\chapter{\",\n                \"\\n\\\\section{\",\n                \"\\n\\\\subsection{\",\n                \"\\n\\\\subsubsection{\",\n                // Now split by environments\n                \"\\n\\\\begin{enumerate}\",\n                \"\\n\\\\begin{itemize}\",\n                \"\\n\\\\begin{description}\",\n                \"\\n\\\\begin{list}\",\n                \"\\n\\\\begin{quote}\",\n                \"\\n\\\\begin{quotation}\",\n                \"\\n\\\\begin{verse}\",\n                \"\\n\\\\begin{verbatim}\",\n                // Now split by math environments\n                \"\\n\\\\begin{align}\",\n                \"$$\",\n                \"$\",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"html\") {\n            return [\n                // First, try to split along HTML tags\n                \"<body>\",\n                \"<div>\",\n                \"<p>\",\n                \"<br>\",\n                \"<li>\",\n                \"<h1>\",\n                \"<h2>\",\n                \"<h3>\",\n                \"<h4>\",\n                \"<h5>\",\n                \"<h6>\",\n                \"<span>\",\n                \"<table>\",\n                \"<tr>\",\n                \"<td>\",\n                \"<th>\",\n                \"<ul>\",\n                \"<ol>\",\n                \"<header>\",\n                \"<footer>\",\n                \"<nav>\",\n                // Head\n                \"<head>\",\n                \"<style>\",\n                \"<script>\",\n                \"<meta>\",\n                \"<title>\",\n                // Normal type of lines\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"sol\") {\n            return [\n                // Split along compiler informations definitions\n                \"\\npragma \",\n                \"\\nusing \",\n                // Split along contract definitions\n                \"\\ncontract \",\n                \"\\ninterface \",\n                \"\\nlibrary \",\n                // Split along method definitions\n                \"\\nconstructor \",\n                \"\\ntype \",\n                \"\\nfunction \",\n                \"\\nevent \",\n                \"\\nmodifier \",\n                \"\\nerror \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo while \",\n                \"\\nassembly \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else {\n            throw new Error(`Language ${language} is not supported.`);\n        }\n    }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"TokenTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"encodingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"allowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"disallowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tokenizer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.encodingName = fields?.encodingName ?? \"gpt2\";\n        this.allowedSpecial = fields?.allowedSpecial ?? [];\n        this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n    }\n    async splitText(text) {\n        if (!this.tokenizer) {\n            this.tokenizer = await getEncoding(this.encodingName);\n        }\n        const splits = [];\n        const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n        let start_idx = 0;\n        while (start_idx < input_ids.length) {\n            if (start_idx > 0) {\n                start_idx -= this.chunkOverlap;\n            }\n            const end_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n            const chunk_ids = input_ids.slice(start_idx, end_idx);\n            splits.push(this.tokenizer.decode(chunk_ids));\n            start_idx = end_idx;\n        }\n        return splits;\n    }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\"),\n        });\n    }\n}\nexport class LatexTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\"),\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["doc"]
}
